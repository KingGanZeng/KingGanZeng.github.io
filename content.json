{"pages":[],"posts":[{"title":"Go语言学习(三)-后台篇(基于beego框架)","text":"Beego框架除了可以拿来做web应用开发外，也集成了swagger来做API自动化文档开发，因为最近在学习后台开发，正好好好撸一把Go后台。因为Iris还没有做很好的文档集成，这里就专注于beego框架，从最简单的登录注册开始。 首先是数据库建设，这里我使用MySQLWorkbench来建表，当然最简单的还是sql语句生成，这里我们建立User用户表，其中包括","link":"/Go语言学习-后台篇/"},{"title":"Django Rest Framework调试之坑","text":"原来想让自己通过项目的方式学习学习Django这一框架，结果拖延症的我到最后开始才做起来，没想到真是给自己挖大坑，这里就记录一下项目进展过程的中遇到的一些问题。 设置非必填项 通过model定义的字段一般都是必填的，如果允许为空的话需要自己设置属性，例如： 123class User(models.Model): uid = models.CharFields(max_length=30, blank=True) weight = models.DecimalField(max_digits=9, decimal_places=2, null=True, blank=True) 需要注意的是：对于时间和输入，允许为空的条件需要123456789101112132. def \\__str__(self)的兼容 关于该函数，在python2和3下有不同的书写方式，需要注意，否则会报错: ```python def __str__(self): # python3写法 return self.record_id # python2写法 return self.record_id.encode(&quot;utf-8&quot;) # 通用写法 return str(self.record_id) 报错信息： TypeError: __str__returned non-string (type bytes)","link":"/Django Rest Framework调试之坑/"},{"title":"Go语言学习(一)-安装篇（Mac）","text":"Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 Go官方下载地址：https://golang.org/ Go中文官方翻译版：http://docscn.studygolang.com/ Mac配置说明 在官网进入下载页面后，选择Apple macOS进行下载： 下载完成后进行一系列“下一步”安装即可，官网给出的说明是： 相当于是官方自动帮我们做了一些安装的操作，不需要在手动建立Go的目录树了，但是请注意，这类仍然需要我们手动去配置GOPATH、GOBIN等环境变量。 完成上述步骤之后，我们可以通过终端来查看go的一些信息： 12knightdeMacBook-Pro-2:~ knight$ go versionknightdeMacBook-Pro-2:~ knight$ go env 可以看到我的版本号为1.11.2，go的一些开发变量也有，这里需要关注的是画红线的两个变量，这里因为我已经配置好了，所以都有显示。正常在做完上述步骤之后，GOBIN应该为空，GOPATH会是’ Users/你的用户名/go ‘，接下来我们来配置需要的环境变量。 在终端中输入： 12knightdeMacBook-Pro-2:Downloads knight$ cd ~knightdeMacBook-Pro-2:Downloads knight$ vim .bash_profile 按下 e 进入编辑模式，再按下 i 进入到插入模式，并输入以下配置： 123export GOPATH=/Users/knight/goexport GOBIN=$GOPATH/binexport PATH=$PATH:${GOPATH//://bin:}/bin GOPATH就是之前go安装是自动帮你生成的文件夹，然后按下esc，再输入qw，最后输入两个大写 Z 完成编辑，接着输入: 1knightdeMacBook-Pro-2:~ knight$ source .bash_profile 这条命令可以让我们的修改立即生效，而不需要注销用户才能生效。 此时再去查看go env，可以发现环境变量都已经配置完成。 然后通过构建一个简单的程序来检查Go的安装是否正确，具体操作如下： 首先创建一个名为 hello.go 的文件，并将以下代码保存在其中： 1234567package mainimport &quot;fmt&quot;func main() { fmt.Printf(&quot;hello, world\\n&quot;)} 接着通过 go 工具运行它： 12$ go run hello.gohello, world 若你看到了“hello, world”信息，那么你的Go已被正确安装。 参考链接：https://blog.csdn.net/dev_csdn/article/details/78740990","link":"/Go语言学习-安装篇/"},{"title":"Go语言学习(二)-框架篇","text":"虽然已经来到了8102年，距离Go语言发布已经过去了十几年，但不得不说Go的框架选择还是很有限的，作为一个Go的初学者，对框架选择主要在以下几点： 1、高性能、上手快 2、提供完整的MVC功能 3、较为完善的文档环境和良好的issue环境 4、持续的维护更新或者大神团队的开发加成 参考了一些文档后，我选择了国内大神开发的beego框架以及国外大神团队开发的Iris框架： Beego：https://beego.me/ （beego的官网设计让我回到了Dreamweaver开发的时代） Iris：https://iris-go.com/ Iris中文网：https://studyiris.com/ （赞一个） 安装过程就不必多说了，按照官网说明按部就班来就行，但是我却遇到了一些问题。 注意：以下问题皆为 macOS 10.14.1 系统，Golang版本 go1.11.2 darwin/amd64 的环境下，当时对应的beego版本位1.10.0，Iris版本为当时最新版本（community-driven version 11.1.0） Beego的安装问题： 在我按照官网的说明安装beego工具时，发生了以下错误 12345678knightdeMacBook-Pro-2:~ knight$ go get github.com/beego/bee# github.com/beego/bee/vendor/github.com/derekparker/delve/procIn file included from go/src/github.com/beego/bee/vendor/github.com/derekparker/delve/proc/proc_darwin.go:3:./proc_darwin.h:1:10: fatal error: 'sys/types.h' file not found#include &lt;sys/types.h&gt; ^~~~~~~~~~~~~1 error generated.knightdeMacBook-Pro-2:~ knight$ 国内的百度对此问题无解，我只能求助Google，果不其然也有人发生了同样的问题，按照上面的方法更新安装我的xcode-install后，还是报出了相同的错误，这时候就要看issue的作用了。 不得不说beego的issue环境做的相当棒，在我发帖没多久后，就收到了两封邮件： 按照后者的操作，顺利的完成了beego的安装，不过看起来这种情况是很少的，而且仅针对与macOS。 关于如何在macOS中快速进入到文件夹（或隐藏文件夹）中，请先点击访达应用-&gt;菜单栏“前往”-&gt;前往文件夹-&gt;输入绝对路径，如这里的 /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg 。Iris的安装问题： 毕竟是国外的框架，自己用学校的网居然遇到了安装不上的情况，建议大家在安装命令时输入： 1knightdeMacBook-Pro-2:~ knight$ go get -v -u github.com/kataras/iris 这样可以方便查看下载安装进度，不会出现让人感觉下载不了的错觉。","link":"/Go语言学习-框架篇/"},{"title":"Koa路由和静态资源中间件初探","text":"Koa作为目前最为轻巧的nodejs框架，搭建SPA（单页面应用）可以说是得心应手，那么今天就来简单入一下Koa这个深坑，主要是总结路由的使用（用于页面切换）以及静态资源的加载，两者都是基于koa的中间件。 一、项目运行环境：​ phpstorm 2018.1版本 ​ nodejs 8.11.1版本 二、项目框架搭建：​ 首先我们现在phpstrom创建一个新的项目，然后在编译器中打开终端，输入: 1npm i koa ​ 等待koa框架创建好后，继续在命令行输入： 1npm init 这一步主要是生成初始的配置表，一直敲回车就可以，这步操作结束后我们可以在package.json中查看到本项目的配置表： 接下来我们要安装两个中间件：koa-route和koa-static，分别为koa封装好的路由以及静态文件加载的插件： 123npm install --save koa-route...npm install --save koa-static 再去查看一下package.json文件，中间件已经加载好了： 基本的配置搭建完毕，接下来是一些简单的应用。 三、项目主体代码：首先在项目根目录下按照这个目录树进行创建(node_modules文件夹里面东西太多，所以这里就不放出来了)： （Tips：Mac可以通过brew install tree安装生成目录树的指令，然后进入到项目文件夹中在终端输入tree来生成目录树，Windows可以直接在命令行输入tree来生成，大家可以查看这篇文章：命令行tree命令生成文件树） 其中view文件夹主要存放我们的html页面，public作为公共文件夹用来存放css以及js文件，接下来首先编辑app.js文件进行配置： 12345678910111213141516171819202122232425'use strict'const koa = require('koa');const route = require('koa-route');const fs = require('fs');const app = new koa();//定义静态资源文件夹app.use(require('koa-static')(__dirname + '/public'));//为不同路由设置不同响应const main = ctx =&gt; { ctx.response.type = 'html'; ctx.response.body = fs.createReadStream('./view/index.html');};const about = ctx =&gt; { ctx.response.type = 'html'; ctx.response.body = fs.createReadStream('./view/about.html');};//定义路由响应,根目录下显示“主页”,about目录下显示“关于页”app.use(route.get('/', main));app.use(route.get('/about',about));app.listen(3300);console.log(\"监听成功，端口号为3300\"); css和js文件这里就不放出了，大家按照正常的写法来写就好，而对于html文件，因为我们要把css和js关联进去，这里要注意关联路径的写法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;!-- 注意路径的写法 --&gt; &lt;link rel=\"stylesheet\" href=\"css/index.css\"&gt; &lt;script src=\"js/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ol id=\"data\"&gt; &lt;li value=\"0\"&gt; 选项1 &lt;ul class=\"hide\" id=\"data_one\"&gt; &lt;li&gt;子选项11&lt;/li&gt; &lt;li&gt;子选项12&lt;/li&gt; &lt;li&gt;子选项13&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li value=\"2\"&gt; 选项2 &lt;ul class=\"hide\" id=\"data_two\"&gt; &lt;li&gt;子选项21&lt;/li&gt; &lt;li&gt;子选项22&lt;/li&gt; &lt;li&gt;子选项23&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li value=\"4\"&gt; 选项3 &lt;ul class=\"hide\" id=\"data_three\"&gt; &lt;li&gt;子选项31&lt;/li&gt; &lt;li&gt;子选项32&lt;/li&gt; &lt;li&gt;子选项33&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ol&gt;&lt;/body&gt;&lt;script&gt;&lt;/script&gt;&lt;/html&gt; 本来正常的写法应该是 12&lt;link rel=\"stylesheet\" href=\"../public/css/index.css\"&gt;&lt;script src=\"../public/js/jquery.js\"&gt;&lt;/script&gt; 因为我们引入了koa的静态资源插件，这里吧把public作为默认的加载路径，因此可以省略，当然你也可以在app.js中自定义路径，把public换成你的路径即可： 123...app.use(require('koa-static')(__dirname + '/public'));... 四、运行结果：运行app.js文件，控制台会输出: 然后我们打开浏览器，在地址栏输入 http://localhost:3300/ 就可以看到我们的界面： 这是我们定义的根目录访问所显示的界面，接下来更改地址栏为 http://localhost:3300/about ，这是我们定义好的路由访问页面： 至此，我们这个小的demo就结束了，大家也可以自己尝试多建立几个页面，但这样对于声明来说比较麻烦，如果采用模板部署，可以减少页面的加载，同时提高页面的性能，有兴趣的可以参阅jquery的template文档来搭建更高效的SPA。","link":"/Koa路由和静态资源中间件初探/"},{"title":"解决vue watch中removeEventListener()不生效的问题","text":"最近在做vue项目，遇到了一个事件绑定的小问题，当我watch某一个data值的变化时，需要对某一个节点绑定事件（先解绑再绑定，防止重复绑定），可以来看下代码： 1234567891011121314151617181920212223242526272829303132...data() { return { quickSelect: '', inputValue: '' }},watch: { inputValue: { handler() { const datePickerPanel = document.querySelector('.date-picker__panel') const _this = this // 闭包取不到vue实例，所以要在这里重新定义 const clearQuickSelect = function () { console.log(1111) _this.quickSelect = '' } // 防止重复监听，先移除之前的 datePickerPanel.removeEventListener('click', clearQuickSelect, false) datePickerPanel.addEventListener('click', clearQuickSelect, false) // 触发panel刷新函数 this.refreshPanel() } }},methods: { refreshPanel() { ... this.quickSelect = 'xxx' ... }}... 我在watch中去声明了一个clearQuickSelect函数，重置quickSelect这个属性，乍一看add和remove的参数完全一致，在实际操作中发现remove并没有生效，原因是啥呢，我还傻乎乎的用箭头函数试了一下，依然还是无法remove。 其实主要问题在于，每次触发watch，都会生成一个新的clearQuickSelect函数，即便名字一样，它所存放的地址也发生了变化，实际上每次remove的clearQuickSelect都是一个新的函数，简单来说，就是生成了clearQuickSelect1() clearQuickSelect2() clearQuickSelect3()，导致解绑不到之前定义的函数。 一个解决办法就是将clearQuickSelect放在methods里，这样一解决了上面的问题，二也不需要考虑闭包取不到正确的this的问题。 说道这里不如来回顾一下从原生到jquery再到目前主流框架的事件绑定方法吧 框架 事件 原生js addEventListener(event, function, useCapture), removeEventListener(event, function, useCapture) jquery $(domSelector).on(event, childSelector, data, function), $(domSelector).off(‘click’) vue 在dom上绑定@click=”func()”或使用原生 react 在dom上绑定onClick=”func()”或使用原生 PS: 原生事件中useCapture为true则表示在捕获阶段触发，否则为冒泡。默认为事件冒泡。 最近面试也被问到了一个问题，如何使用原生事件实现jquery的on，简单想了一种写法： 123456789101112131415&lt;div id=\"father\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; // jquery的写法 $('#father').on('click', '.child', function () {console.log(111111)} ) // 用原生实现 const father = document.getElementById('father') father.addEventListener('click', function(e) { if (e &amp;&amp; e.target.className = 'child') { console.log(222222) } })&lt;/script&gt;","link":"/addEventListener()与removeEventListener()/"},{"title":"node.js非管道方法读写错误问题","text":"今天在学习node.js流的时候，参照菜鸟教程的文档写了从流中读取和写入数据的操作，但是在两者同时运行的时候，却发现写入文档并没有任何数据写入。 先上最初的错误代码： 12345678910111213141516171819202122232425262728293031//引入流模块var fs = require('fs');var data = '';var readerStream = fs.createReadStream('input.txt');var writerStream = fs.createWriteStream('output.txt'); //将文档从input.txt中读取出来存入流readerStream.on('data', function(chunk){ console.log(\"1、Start:\"); data += chunk;});readerStream.on('end', function(){ console.log(\"2、\" + data);});readerStream.on('error', function(err){ console.log(err.stack);})；//从流中读取数据写入output.txtwriterStream.write(data, 'UTF8');writerStream.end();writerStream.on('finish', function(){ console.log(\"3、Write done!\"); console.log(\"4、All done!\");});writerStream.on('err', function(err){ console.log(err.stack);});console.log(\"5、Program Finished！\"); 1Hello world! 程序的运行结果如下： 123455、Program Finished!1、Start:3、Write done!4、All done!2、Hello world! 这时去查看同目录下生成的output.txt是没有内容的，根据以上代码，显然在进行写入操作时，data变量还没有数据读入，因此output写入数据为空（你也可以尝试定义data为一个字符串进行测试）。 接下来对写入流（writerStream）设定一个定时器，1秒后进行操作，修改代码为： 12345678...setTimeout(function(){ writerStream.write(data, 'UTF8');},1000);setTimeout(function(){ writeStream.end();},2000)... 这里需要注意，在对写操作设置定时器的时候，需要对end方法也设定定时器，并且时间需要大于我们写操作定时器的时间，不然会出现以下错误： 12Error: write after end... 最终调试到以下阶段： 123456789...setTimeout(function(){ writerStream.write(data, 'UTF8');},3);//定时为2则抛出'Error: write after end'setTimeout(function(){ writeStream.end();},5)... 可以看到从文件中读取数据至少要3ms（实际的读取时间跟文件路径以及大小有关），而程序读取完只需要不到1ms，所以才出现了最开始写入数据为空的bug。这也侧面说明了node.js的异步处理方式。 当然，其实node.js已经帮我们做好了这一堆繁杂的操作，管道流（pipe）很好的解决了这一个问题，我们的代码可以简化为： 1234567var fs = require('fs');var readerStream = fs.createReadStream('input.txt');var writeeStream = fs.createWriteStream('output.txt');readerStream.pipe(writeStream);console.log(\"All done!\"); 上述的操作会使得output.txt内容被覆写，如果你只想在output.txt中追加内容，可以在定义写入流的时候追加参数: 1var writeeStream = fs.createWriteStream('output.txt',{'flags' : 'a' }); 可用的参数列表如下： flag 说明 r 读取文件。如果文件不存在则抛出异常 r+ 读取并写入。如果文件不存在时抛出异常 rs 以同步方式读取文件并通知操作系统忽略本地文件系统缓存 w 写入文件。文件不存在则创建该文件，存在则清空文件内容 w+ 读取并写入文件。文件不存在则创建该文件，存在则清空文件内容 wx 作用与”w”类似。但以排他方式打开文件 wx+ 作用与”w+”类似。但以排他方式打开文件 a 以追加方式写入文件。如果文件不存在则创建该文件 a+ 读取并以追加方式写入文件。如果文件不存在则创建该文件 ax 作用与”a”相似。但以排他方式打开文件 ax+ 作用与”a+”相似。但以排他方式打开文件","link":"/node.js传统读写流的时间先后问题/"},{"title":"关于一个监控平台的点点(一)","text":"想要搭建一个前端的性能监控平台，首先要从认识监控指标开始，在浏览器控制台中输入window.performance.timing(html5的属性)就可以获取到了，而window.performance也为我们提供了丰富的指标，帮助我们计算我们监控所需要的内容。下面这张图就是网页在各个阶段可以读取到的时间戳： /1.png) 下面我们来一一解释各个字段的意义：（斜体为不常用的属性） 字段名 意义 navigationStart 当前浏览器窗口的前一个网页关闭，发生unload事件时的Unix毫秒时间戳。如果没有前一个网页，则等于fetchStart属性。 unloadEventStart 如果前一个网页与当前网页属于同一个域名，则返回前一个网页的unload事件发生时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。 unloadEventEnd 如果前一个网页与当前网页属于同一个域名，则返回前一个网页unload事件的回调函数结束时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。 redirectStart 返回第一个HTTP跳转开始时的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。 redirectEnd 返回最后一个HTTP跳转结束时（即跳转回应的最后一个字节接受完成时）的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。 fetchStart 返回浏览器准备使用HTTP请求读取文档时的Unix毫秒时间戳。该事件在网页查询本地缓存之前发生。 domainLookupStart 返回域名查询开始时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。 domainLookupEnd 返回域名查询结束时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。 connectStart 返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值。 connectEnd 返回浏览器与服务器之间的连接建立时的对Unix毫秒时间戳，如果建立的连接是持久的，则返回值等同于fetchStart的值。连接建立指的是所有握手和认证过程全部结束 secureConnectionStart 返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全链接，则返回0 requestStart 返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳 reponseStart 返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳 responseEnd 返回浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳。 domLoading 返回当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的readystatechange事件触发时）的Unix毫秒时间戳。 domInteractive 返回当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的Unix毫秒时间戳。 domContentLoadedEventStart 返回当前网页DOMContentLoaded事件发生时（即DOM结构解析完毕、所有脚本开始运行时）的Unix毫秒时间戳。 domContentLoadedEventEnd 返回当前网页所有需要执行的脚本执行完成时的Unix毫秒时间戳。 domComplete 返回当前网页DOM结构生成时（即Document.readyState属性变为“complete”，以及相应的readystatechange事件发生时）的Unix毫秒时间戳。 loadEventStart 返回当前网页load事件的回调函数开始时的Unix毫秒时间戳。如果该事件还没有发生，返回0。 loadEventStart 返回当前网页load事件的回调函数运行结束时的Unix毫秒时间戳。如果该事件还没有发生，返回0。通过while循环持续判断直到loadEventEnd&gt;0则表示完全加载完毕了，此时网络不再有任何数据请求、dom也渲染完毕了 这么多的属性，看起来真的很费眼，不过如果你看到了这里，说明你还是对怎么监控很感兴趣的，不管做啥都要有耐心嘛 接下来我们就来开始说说人话——我们到底该监控哪些指标。 对于前端开发人员而言，最关键的在于四个指标：白屏时间、DOM树构建时间、页面加载时间和首屏时间，简单介绍一下这四位好汉： 白屏时间（wit）：指的是浏览器开始显示内容的时间，对于现代浏览器而言，页面内容的展示不会等待DOM树（body标签的解析）和CSS树（所有的css文件下载和解析）完全完成再开始渲染，而是马上开始显示中间结果。这也就是我们在弱网环境下看到的，页面先显示文字再加载样式，或者页面从上到下进行渲染的效果。 鉴于上述特性，我们可以通过 responseStart - navigationStart 来近似的获得白屏时间，也即：页面接收到请求返回结果时间 - 页面准备开始请求的时间（或前一个网页卸载的时间） DOM树构建时间（domt）：指的是浏览器从html文档中构建DOM树的时间，最初大家都是用onLoad中获取DOM树构建的时间，但是由于这个函数只有在页面所有资源都加载完成之后才会触发，一旦有一个资源被阻塞了，我们就无法获取到正确的时间了（这个方法可以在jquery中使用$dom.ready(function(){})来使用）。由此，DomReady事件便诞生了，它在DOM树加载之后立即执行。我们可以通过监听这个事件来获取时间戳： 123document.onreadystatechange = func () { console.log(+new Date())}; 注意：这个函数仅仅是文档被加载并完成解析了，但是图像、样式表和框架之类的子资源仍然在加载中。 当然，做到这一步需要对原生代码进行注入，意味着你需要app端或者pc端的开发人员帮你将这段代码放在业务代码中。如果你嫌麻烦，也可以采用performance的指标来获取：domComplete - domLoading ，也即：页面DOM结构生成的时间 - 页面的DOM结构开始解析的时间 首屏时间(firstt)：指的是用户看到的第一屏，也就是当前视窗大小的页面内容完全加载完成，例如iPhone X的屏幕尺寸为 375 * 812，而我的页面总长度为1314px，那么从页面顶部开始的812px就是我首先会展示给用户的区域，也即首屏。 首屏加载时间是直接影响用户体验的 （Tips：在国内的网络条件下，通常一个网站，如果“首屏时间”在2秒以内是比较优秀的，5秒以内用户可以接受，10秒以上就不可容忍了） 页面加载时间（loadt）：指的是页面完成整个加载后结束的时间，指页面完成整个加载过程的时刻。从Navigation Timing API上采集，就是loadEventEnd减去navigationStart。","link":"/关于一个监控平台的点点(一)/"},{"title":"命令行tree命令生成文件树","text":"为了方便查看文件内容以及相关目录，我们一般用文件树进行操作，在windows系统下，我们可以直接使用tree命令进行操作： 1tree &gt; list.txt 实例图片如下： 这样我们可以生成koa-learn这个文件夹下的所有文件目录，输出结果为： 那么对于Mac OS或者Linux系统，可以通过以下命令安装tree这个生成插件，打开终端并输入：（没有安装brew请先输入brew install） 1brew install tree 然后等待安装完毕，因为是国外的服务器，所以下载可能比较慢。 然后进入到文件夹下，在命令行输入： 1tree -a 接着我们可以在终端看到当前的目录树： 除此之外我们还有其他的参数可以设置： 命令行 效果 tree -d 只显示文件夹 tree -D 显示文件的最后修改时间 tree -L n n表示显示项目的层级，n=3即只显示项目的三层结构 tree -I pattern pattern表示想要过滤的目录，例如 tree -I “node_modules”可以过滤掉node_modules这个文件夹 注意，这里的参数-d、-D区分大小写，大家可以自行实验。","link":"/命令行tree命令生成文件树/"},{"title":"基于Express框架的图片压缩上传","text":"在网上查看了很多技术文档，也阅读了Express官方的技术文档，很多在运行上都多少会有一些问题，所以决定今天把程序从创建到运行完整的记录下来，方便参考。其中第三部分使用了canvas的图片压缩，如果你只需要压缩部分的代码说明，可以直接跳至第三部分。 一、运行环境及基本配置说明：​ phpstorm 2018.1版本 ​ nodejs 8.11.1版本 ​ Express 4.16.0版本 二、项目创建及框架的搭建​ 首先我们运行phpstorm，并create new project： 因为我是初学者，对于node的模板部署还不是很熟悉，所以这里用了静态的html（其实后来都把css和js写在html文档里了，所以这一部分默认属性也不会产生影响） 项目创建好之后，我们主要对下面三个文件：index.html、app.js以及package.json进行操作： 因为上传文件我们需要用到express的multer中间件，所以这里也要先配置好（默认是没有的），打开命令行，进入项目的目录中： 然后输入： 1npm install express multer --save 等待完成： 这时我们再去查看项目的package.json文件，可以看到我们的中间件已经添加成功： 基本配置已经完成，接下来就是代码上场。 三、图片压缩模块：这一部分不牵扯express框架或者nodejs，为纯html和js的canvas图片压缩，如果你只需要做这一部分的话，可以单独使用，无需前两部分的操作。 canvas进行图片压缩的原理简单来说，就是将原来的图片转为base64格式的代码，然后重新绘制在画布上。其实也可以理解为将一幅巨大的壁画，重新copy在一张小的画布上，并删除一些细节的过程。 那么先上我们的html代码，这里我把css也写进去了（虽然说并没有用什么样式）： 123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt; &lt;title&gt;photo——compress&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/stylesheets/style.css\"&gt; &lt;style&gt; #modify_img{ display: block; width: 300px; height: 300px; background-size: 100% 100%; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"img_post\"&gt; &lt;img src=\"images\" alt=\"\" id=\"modify_img\"&gt; &lt;input id=\"file\" type=\"file\" accept=\"image/*\"&gt; &lt;button id=\"upload\"&gt;上传&lt;/button&gt; &lt;span id=\"progress\"&gt;0%&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 下面来逐一说明，div里面的标签： “img”：必要，主要是为canvas画布固定一个位置，它必须设置为block显示， 同时设置宽高，其中的background-size属性是防止图片本来就很小而无法完全占满整个框造成显示错误的情况。 “input”：必要，设置id和input属性，同时只允许选择图片类型文件，在点击选择完文件后，会自动在”img”中生成压缩好的图片。 “button”：必要（如果不需要上传功能可忽略），点击按钮可以将压缩好的图片上传至express服务器，同时控制台会返回相关信息。 “span”：不必要，主要是为了显示上传进度。 接下来是canvas绘图的代码，因为写的时候已经注释好了，后面就不再逐一赘述： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var getfile = document.querySelector('#file'); //获取文件中id为file的元素 var reader = new FileReader(); //FileReader对象允许WEB应用程序异步读取存储在用户计算机上的文件 var img = new Image(); //Image功能等价于 document.createElement('img') var file = null; var canvas = document.createElement('canvas'); var context = canvas.getContext('2d'); //返回一个用于在画布上绘图的环境，目前唯一合法值为“2d” var newUrl = null;//对input绑定事件监听，当内容改变时触发 getfile.addEventListener('change', function(event){ file = event.target.files[0]; if ( file.type.indexOf(\"image\") == 0 ){ reader.readAsDataURL(file); } })； reader.onload = function(e){ //当文件上传完后触发，主要是为了获取源文件的长宽 img.src = e.target.result; }; img.onload = function(){ //在图片加载完成后立即发生 var orgin_width = this.width; var orgin_height = this.height; var max_width = 300; var max_height = 300; var target_width = orgin_width; var target_height= orgin_height; if (orgin_width &gt; max_width || orgin_height &gt; max_height){ //判断图像是否大于限定的最大长宽 if (orgin_width / orgin_height &gt; max_width / max_height){ //上传图像的宽高比较大，以宽为长轴对高进行拉伸 target_width = max_width; target_height = Math.round(max_width * ( orgin_height / orgin_width )); //round（）方法表示四舍五入取整数 } else { target_width = Math.round(max_height * ( orgin_width / orgin_height )); //高宽比较大，以高为长轴，对宽进行缩短 target_height = max_height; } } canvas.width = target_width; canvas.height = target_height; //如果是png转jpg如果canvas存在透明区域，实际绘制出来会变为黑色，因为canvas默认为rgba(0,0,0,0) //在转成jpg的时候变成了rgba(0,0,0,1),解决办法就是在绘制之前为canvas铺上一层白色的底色 context.fillStyle = \"#FFF\"; context.fillRect(0, 0, target_width, target_height); //绘制已填充矩形 //context.clearRect(0, 0, target_width, target_height); //清除画布并设置宽高 context.drawImage(img, 0, 0, target_width, target_height); //绘画 newUrl = canvas.toDataURL('image/jpeg', 0.92); //base64 格式 modify_img.style.backgroundImage='url(' + newUrl + ')'; }; 设置好后点击右上角的chrome进行测试: 页面显示如下（请无视那个button的乱码，过会我们用服务器进行测试就正常了）: 为了测试，我选择了一张1.3M的照片： 点击打开后，图片会进行压缩，然后显示在”img”标签里，可以明显的通过图片的锯齿感看出图片已经进行了压缩： 这时候如果我们去检查文档，会发现图片已经被转为了base64编码： 到此，我们的canvas已经顺利完成了图片的压缩工作，接下来就是服务器上场。 四、利用Express的multer中间件实现文件与服务器的交互当时在做这一部分的时候走了很多弯路，因为express4.x已经不再包括body-parser，需要自己进行相关配置，搞得很头痛。后来发现到最新的express已经为我们提供了multer这个中间件，方便了不少，接下来先上js的代码： 1234567891011121314151617181920212223242526272829303132333435363738var upload = document.querySelector('#upload'); //为\"上传\"按钮绑定变量 var progress = document.querySelector('#progress'); //为进度条绑定变量 var xhr = new XMLHttpRequest(); //定义xhr upload.addEventListener('click', uploadFile, false); //设置按钮点击事件 function uploadFile(event){ function dataURLtoFile(dataurl, filename) { //将我们上面转换的base64格式编码转为文件类型 var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while(n--){ u8arr[n] = bstr.charCodeAt(n); } return new File([u8arr], filename, {type:mime}); } var file_img = dataURLtoFile(newUrl, file.name); //定义文件类型的图片 var formData = new FormData(); //定义formdata的处理方法 formData.append('test-upload', file_img); //定义处理域以及文件传入 xhr.onload = uploadSuccess; //上载成功的返回函数 xhr.upload.onprogress = setProgress; //处理进度的放回函数 xhr.open('post', '/upload', true); //ajax数据请求方法 xhr.send(formData); //ajax数据发送方法 } function uploadSuccess(event){ if(xhr.readyState === 4){ console.log(xhr.responseText); } } function setProgress(event) { if (event.lengthComputable) { var complete = Number.parseInt(event.loaded / event.total * 100); progress.innerHTML = complete + '%'; } } 这里需要注意的是 123...var file_img = dataURLtoFile(newUrl, file.name); //定义文件类型的图片... 第二个参数file.name中，file为第三部分中定义过的file，目的是为了传入压缩过的文件名称，如果需要修改请将dataURLtoFile()函数一并修改。 然后我们需要对express进行一些配置，在第二部分我们已经引入中间件，那么只需要在app.js中进行引入。首先在文件头定义上传和文件这两个变量，方便我们使用，并设置好端口号：(省略号之间的为新写入的内容！！！) 1234567var logger = require('morgan');//...var upload = require('multer')({ dest: 'uploads/' }); //上传图片保存的文件夹为uploadsvar fs = require('fs');var port = 8000;//...var indexRouter = require('./routes/index'); 接下来定义文件的上传输出信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243app.use('/users', usersRouter);//...app.set('port', port);app.get('*', (req, res) =&gt; { res.redirect('index.html');});app.post('/upload', upload.single('test-upload'), (req, res) =&gt; { // 没有附带文件 if (!req.file) { res.json({ ok: false }); return; } // 输出文件信息 console.log('===================================================='); console.log('fieldname: ' + req.file.fieldname); console.log('originalname: ' + req.file.originalname); console.log('encoding: ' + req.file.encoding); console.log('mimetype: ' + req.file.mimetype); console.log('size: ' + (req.file.size / 1024).toFixed(2) + 'KB'); console.log('destination: ' + req.file.destination); console.log('filename: ' + req.file.filename); console.log('path: ' + req.file.path); // 重命名文件 let oldPath = path.join(__dirname, req.file.path); let newPath = path.join(__dirname, 'uploads/' + req.file.originalname); fs.rename(oldPath, newPath, (err) =&gt; { if (err) { res.json({ ok: false }); console.log(err); } else { res.json({ ok: true }); } });});app.listen(port, () =&gt; { console.log(\"[Server] localhost:\" + port);});//...module.exports = app; 至此，我们的上传功能也搭建完毕。 五、程序运行：上述操作全部完成后，因为编译器已经帮我们配好了运行环境（真的是省了一大步的事），所以我们只需要点击右上角的绿色小箭头： 运行： 这时我们的服务器已经启动了，打开chrome，输入http://localhost:8000/ 就可以看到我们的界面了，然后选择文件后点击上传，进度显示100%就代表上传成功： 控制台返回给我们图片的相关信息： 可以看到图片从1.3M压缩到了33.33KB，同时存放路径为uploads的文件夹； 接下来到我们定义好的存图片的地方： 然后，然后就开心的玩这个东西了，😝。 其实express也可以通过裁剪的方式进行图片压缩，不过那需要现将源文件上传至服务器（还是会浪费流量，而且加载速度也会受影响）；使用canvas先在本地进行图片压缩，然后上传服务器，这是目前主流的做法。本项目需要注意的点在于压缩好后的图片只是存在的标签下，而上传的需要是文件，这就需要用dataURLtoFile()这一个函数将图片进行转化，再对文件进行上传。否则将这一部分代码改为： 123...formData.append('test-upload', file); ... 上传的仍然是未被压缩的源文件。","link":"/基于Express框架的图片压缩上传/"},{"title":"如何在EC2上部署webpack打包项目","text":"本篇主要包含以下几部分： EC2的申请与配置注意 ubuntu服务器相关配置 nginx的配置及域名访问 项目的整体配置及版本： 服务器类型：AWS EC2服务器 服务器系统：Ubuntu 18.04 nvm版本：0.33.2 node版本：11.13.0 npm版本：6.7.0 vue版本：2.9.6 nginx版本：1.14.0 (Ubuntu) git版本：2.21.0 EC2的申请与配置注意首先你必须有一个亚马逊账户，进入AWS的控制面板，通过服务/计算/EC2进入到下一层的控制面板中，然后点选启动实例，选择服务器的相关配置等等。 在这一些操作后，你需要新建一个安全组来允许你从远程访问。关于安全组的配置，可以参考下图： 80端口和8080端口开发用于让我们通过域名或IP地址访问我们的站点，22端口用于我们通过SSH来链接远程服务器，进行相关的配置。 出站规则设置成全部端口，任意IP均可访问即可。 全部完成后，就可以在实例中看到我们部署好的服务器，类似第一张图，点击我们刚部署好的服务器，可以看到服务器的ip地址（红框内容），用户可以通过ip来进行访问，也用于我们最后要配置的域名解析： 再点击“连接”按钮，会给我们连接所需的相关信息： 其中 公有DNS 便是我们连接的主机，默认端口号为22，接下来可以使用合适的SSH客户端来链接远程主机。 Mac：FinalShell Windows：Xshell 接下来以FinalShell为例，我们来链接远程服务器： 然后点击文件夹，选择ssh链接： 然后填写链接相关信息： 名称随意，主机即为刚才的 公有DNS 认证方式选择公钥认证，用户名填写 ubuntu ，私钥即为刚才创建实例所保存的 .pem 文件，全部填写完毕后点击确定，即可链接远程服务器。 ubuntu服务器相关配置123~$: sudo apt install curl~$: curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash(执行完这一步后需要重启shell，直接把当前shell关闭再重新进入就好了，否则nvm命令无法找到) 1234567891011121314~$: nvm --version // 查看nvm版本~$: nvm ls-remote // 查看node版本~$: nvm install v11.13.0 // 下载指定node版本~$: node --version~$: npm --version (node相关配置完毕)~$: npm install -g vue-cli(vue相关配置完毕)~$: sudo add-apt-repository ppa:git-core/ppa // 部署国内服务器可以不做这一步~$: sudo apt-get update~$: sudo apt-get install git(git相关配置完毕)~$: sudo apt-get install nginx(nginx安装完毕) 接下来我们需要把项目clone到服务器上，可以借助github来完成这一步，当然有兴趣的同学可以使用webstorm的deployment来完成这一步。 123~$: git clone https://github.com/[xxxx]/[projectName].git~/[projectName]$: cd [projectName] &amp;&amp; npm install~/[projectName]$: npm run build 上述操作完成后，我们的项目已经完成了打包并存放在我们的服务器上了，这是其实可以通过 run dev 然后使用共有 ip + 端口号访问了，接下来我们将使用nginx实现域名的访问。 nginx的配置及域名访问首先我们准备好域名，去阿里云或者腾讯云上搞一个域名，全部审批完后，点击域名解析： 然后点击新手引导来添加服务器的ip地址（之前我们保存的服务器公有IP），保存确认即可： 搞定好这个之后，我们回到SSH上完成nginx代理。之前我们已经安装好了nginx，接下来进行nginx的配置： 12~$: cd /etc/nginx/etc/nginx$: sudo vim nginx.conf 然后修改相关配置： 123456789101112http { ... server { listen 80; server_name xxx.cn; location / { root /home/ubuntu/[projectName]/dist; index index.html; } }} 然后按下esc，输入 :wq 保存退出， 接着在终端中重启nginx： 1/etc/nginx$: sudo service nginx restart 这样我们服务器端就全部配置完成了，可以愉快的通过域名来访问了。","link":"/如何在EC2上部署webpack打包项目/"},{"title":"Antlr4入门学习-安装配置（Mac）","text":"最近开始进入到毕设的工作中，目标是完成一个基于antlr4的高级计算器，本文为antlr的入门安装教程。 Mac&amp;Linux的配置说明首先是下载，进入到系统配置目录下，使用curl命令对文件进行下载： 12knightdeMacBook-Pro-2:~ knight$ cd /usr/local/libknightdeMacBook-Pro-2:lib knight$ sudo curl -O https://www.antlr.org/download/antlr-4.7.1-complete.jar 下载完成后，注意重启bash，在这一路径下进行vim的操作 1knightdeMacBook-Pro-2:~ knight$ vim .bash_profile 当然也可以cd /Users/YourName 来进行操作 123knightdeMacBook-Pro-2:lib knight$ cd /Users/KnightknightdeMacBook-Pro-2:Knight knight$ cd ~knightdeMacBook-Pro-2:~ knight$ vim .bash_profile 然后进入到vim编辑器中，修改路径并设置快捷名（如果出现下列情况，选择edit anyway 或者先 quit 后再 edit） 进入之后由于现在vim处于命令模式，不能对内容进行修改，我们输入i即可（insert模式） 1234*export CLASSPATH=&quot;.:/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH&quot;alias antlr4=&apos;java -jar /usr/local/lib/antlr-4.0-complete.jar&apos;alias grun=&apos;java org.antlr.v4.runtime.misc.TestRig&apos; 如下图： 这一步配置完成后，按esc后退回到命令模式，然后输入qw，接着输入两个大写Z即可保存退出。 接下来运行 1knightdeMacBook-Pro-2:~ knight$ source .bash_profile source 命令是为了重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。这时候antlr的系统配置已经完成了。 我们输入antlr4或者grun可以查看版本信息： 关键的操作是快捷配置这一步，之前按照官网直接在usr/local/lib下输入export并不能使得配置生效，导致每次在重启项目后都需要重新配置，后来才发现是导入的位置不对。","link":"/Antlr4入门学习-安装配置/"}],"tags":[{"name":"知识学习","slug":"知识学习","link":"/tags/知识学习/"},{"name":"项目实战","slug":"项目实战","link":"/tags/项目实战/"},{"name":"错误总结","slug":"错误总结","link":"/tags/错误总结/"},{"name":"小技巧","slug":"小技巧","link":"/tags/小技巧/"}],"categories":[{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Koa","slug":"Koa","link":"/categories/Koa/"},{"name":"JS","slug":"JS","link":"/categories/JS/"},{"name":"NodeJs","slug":"NodeJs","link":"/categories/NodeJs/"},{"name":"NodeJs Vue Koa ElasticSearch","slug":"NodeJs-Vue-Koa-ElasticSearch","link":"/categories/NodeJs-Vue-Koa-ElasticSearch/"},{"name":"Bash/cmd","slug":"Bash-cmd","link":"/categories/Bash-cmd/"},{"name":"Node","slug":"Node","link":"/categories/Node/"},{"name":"Antlr4","slug":"Antlr4","link":"/categories/Antlr4/"}]}