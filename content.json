{"meta":{"title":"KingGanZeng`s blogs","subtitle":"Stay hungry，stay foolish","description":null,"author":"Knight Zeng","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"命令行tree命令生成文件树","slug":"命令行tree命令生成文件树","date":"2018-05-15T02:37:21.000Z","updated":"2018-05-15T03:11:01.656Z","comments":true,"path":"命令行tree命令生成文件树/","link":"","permalink":"http://yoursite.com/命令行tree命令生成文件树/","excerpt":"为了方便查看文件内容以及相关目录，我们一般用文件树进行操作，在windows系统下，我们可以直接使用tree命令进行操作： 1tree &gt; list.txt","text":"为了方便查看文件内容以及相关目录，我们一般用文件树进行操作，在windows系统下，我们可以直接使用tree命令进行操作： 1tree &gt; list.txt 实例图片如下： 这样我们可以生成koa-learn这个文件夹下的所有文件目录，输出结果为： 那么对于Mac OS或者Linux系统，可以通过以下命令安装tree这个生成插件，打开终端并输入：（没有安装brew请先输入brew install） 1brew install tree 然后等待安装完毕，因为是国外的服务器，所以下载可能比较慢。 然后进入到文件夹下，在命令行输入： 1tree -a 接着我们可以在终端看到当前的目录树： 除此之外我们还有其他的参数可以设置： 命令行 效果 tree -d 只显示文件夹 tree -D 显示文件的最后修改时间 tree -L n n表示显示项目的层级，n=3即只显示项目的三层结构 tree -I pattern pattern表示想要过滤的目录，例如 tree -I “node_modules”可以过滤掉node_modules这个文件夹 注意，这里的参数-d、-D区分大小写，大家可以自行实验。","categories":[],"tags":[{"name":"TIPS","slug":"TIPS","permalink":"http://yoursite.com/tags/TIPS/"}]},{"title":"Koa路由和静态资源中间件初探","slug":"Koa路由和静态资源中间件初探","date":"2018-05-10T09:27:51.000Z","updated":"2018-05-15T05:22:06.413Z","comments":true,"path":"Koa路由和静态资源中间件初探/","link":"","permalink":"http://yoursite.com/Koa路由和静态资源中间件初探/","excerpt":"Koa作为目前最为轻巧的nodejs框架，搭建SPA（单页面应用）可以说是得心应手，那么今天就来简单入一下Koa这个深坑，主要是总结路由的使用（用于页面切换）以及静态资源的加载，两者都是基于koa的中间件。 一、项目运行环境：​ phpstorm 2018.1版本 ​ nodejs 8.11.1版本","text":"Koa作为目前最为轻巧的nodejs框架，搭建SPA（单页面应用）可以说是得心应手，那么今天就来简单入一下Koa这个深坑，主要是总结路由的使用（用于页面切换）以及静态资源的加载，两者都是基于koa的中间件。 一、项目运行环境：​ phpstorm 2018.1版本 ​ nodejs 8.11.1版本 二、项目框架搭建：​ 首先我们现在phpstrom创建一个新的项目，然后在编译器中打开终端，输入: 1npm i koa ​ 等待koa框架创建好后，继续在命令行输入： 1npm init 这一步主要是生成初始的配置表，一直敲回车就可以，这步操作结束后我们可以在package.json中查看到本项目的配置表： 接下来我们要安装两个中间件：koa-route和koa-static，分别为koa封装好的路由以及静态文件加载的插件： 123npm install --save koa-route...npm install --save koa-static 再去查看一下package.json文件，中间件已经加载好了： 基本的配置搭建完毕，接下来是一些简单的应用。 三、项目主体代码：首先在项目根目录下按照这个目录树进行创建(node_modules文件夹里面东西太多，所以这里就不放出来了)： . ├── app.js ├── package-lock.json ├── package.json ├── public │ ├── css │ │ ├── about.css │ │ └── index.css │ └── js │ ├── index.js │ └── jquery.js ├── view │ ├── about.html │ └── index.html └── node_modules （Tips：Mac可以通过brew install tree安装生成目录树的指令，然后进入到项目文件夹中在终端输入tree来生成目录树，Windows可以直接在命令行输入tree来生成，大家可以查看这篇文章：#） 其中view文件夹主要存放我们的html页面，public作为公共文件夹用来存放css以及js文件，接下来首先编辑app.js文件进行配置： 12345678910111213141516171819202122232425'use strict'const koa = require('koa');const route = require('koa-route');const fs = require('fs');const app = new koa();//定义静态资源文件夹app.use(require('koa-static')(__dirname + '/public'));//为不同路由设置不同响应const main = ctx =&gt; &#123; ctx.response.type = 'html'; ctx.response.body = fs.createReadStream('./view/index.html');&#125;;const about = ctx =&gt; &#123; ctx.response.type = 'html'; ctx.response.body = fs.createReadStream('./view/about.html');&#125;;//定义路由响应,根目录下显示“主页”,about目录下显示“关于页”app.use(route.get('/', main));app.use(route.get('/about',about));app.listen(3300);console.log(\"监听成功，端口号为3300\"); css和js文件这里就不放出了，大家按照正常的写法来写就好，而对于html文件，因为我们要把css和js关联进去，这里要注意关联路径的写法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;!-- 注意路径的写法 --&gt; &lt;link rel=\"stylesheet\" href=\"css/index.css\"&gt; &lt;script src=\"js/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ol id=\"data\"&gt; &lt;li value=\"0\"&gt; 选项1 &lt;ul class=\"hide\" id=\"data_one\"&gt; &lt;li&gt;子选项11&lt;/li&gt; &lt;li&gt;子选项12&lt;/li&gt; &lt;li&gt;子选项13&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li value=\"2\"&gt; 选项2 &lt;ul class=\"hide\" id=\"data_two\"&gt; &lt;li&gt;子选项21&lt;/li&gt; &lt;li&gt;子选项22&lt;/li&gt; &lt;li&gt;子选项23&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li value=\"4\"&gt; 选项3 &lt;ul class=\"hide\" id=\"data_three\"&gt; &lt;li&gt;子选项31&lt;/li&gt; &lt;li&gt;子选项32&lt;/li&gt; &lt;li&gt;子选项33&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ol&gt;&lt;/body&gt;&lt;script&gt;&lt;/script&gt;&lt;/html&gt; 本来正常的写法应该是 12&lt;link rel=\"stylesheet\" href=\"../public/css/index.css\"&gt;&lt;script src=\"../public/js/jquery.js\"&gt;&lt;/script&gt; 因为我们引入了koa的静态资源插件，这里吧把public作为默认的加载路径，因此可以省略，当然你也可以在app.js中自定义路径，把public换成你的路径即可： 123...app.use(require('koa-static')(__dirname + '/public'));... 四、运行结果：运行app.js文件，控制台会输出: 然后我们打开浏览器，在地址栏输入 http://localhost:3300/ 就可以看到我们的界面： 这是我们定义的根目录访问所显示的界面，接下来更改地址栏为 http://localhost:3300/about ，这是我们定义好的路由访问页面： 至此，我们这个小的demo就结束了，大家也可以自己尝试多建立几个页面，但这样对于声明来说比较麻烦，如果采用模板部署，可以减少页面的加载，同时提高页面的性能，有兴趣的可以参阅jquery的template文档来搭建更高效的SPA。","categories":[],"tags":[{"name":"Koa","slug":"Koa","permalink":"http://yoursite.com/tags/Koa/"}]},{"title":"基于Express框架的图片压缩上传","slug":"基于Express框架的图片压缩上传","date":"2018-05-07T05:11:15.238Z","updated":"2018-05-08T05:53:34.258Z","comments":true,"path":"基于Express框架的图片压缩上传/","link":"","permalink":"http://yoursite.com/基于Express框架的图片压缩上传/","excerpt":"在网上查看了很多技术文档，也阅读了Express官方的技术文档，很多在运行上都多少会有一些问题，所以决定今天把程序从创建到运行完整的记录下来，方便参考。其中第三部分使用了canvas的图片压缩，如果你只需要压缩部分的代码说明，可以直接跳至第三部分。 一、运行环境及基本配置说明：​ phpstorm 2018.1版本 ​ nodejs 8.11.1版本 ​ Express 4.16.0版本","text":"在网上查看了很多技术文档，也阅读了Express官方的技术文档，很多在运行上都多少会有一些问题，所以决定今天把程序从创建到运行完整的记录下来，方便参考。其中第三部分使用了canvas的图片压缩，如果你只需要压缩部分的代码说明，可以直接跳至第三部分。 一、运行环境及基本配置说明：​ phpstorm 2018.1版本 ​ nodejs 8.11.1版本 ​ Express 4.16.0版本 二、项目创建及框架的搭建​ 首先我们运行phpstorm，并create new project： 因为我是初学者，对于node的模板部署还不是很熟悉，所以这里用了静态的html（其实后来都把css和js写在html文档里了，所以这一部分默认属性也不会产生影响） 项目创建好之后，我们主要对下面三个文件：index.html、app.js以及package.json进行操作： 因为上传文件我们需要用到express的multer中间件，所以这里也要先配置好（默认是没有的），打开命令行，进入项目的目录中： 然后输入： 1npm install express multer --save 等待完成： 这时我们再去查看项目的package.json文件，可以看到我们的中间件已经添加成功： 基本配置已经完成，接下来就是代码上场。 三、图片压缩模块：这一部分不牵扯express框架或者nodejs，为纯html和js的canvas图片压缩，如果你只需要做这一部分的话，可以单独使用，无需前两部分的操作。 canvas进行图片压缩的原理简单来说，就是将原来的图片转为base64格式的代码，然后重新绘制在画布上。其实也可以理解为将一幅巨大的壁画，重新copy在一张小的画布上，并删除一些细节的过程。 那么先上我们的html代码，这里我把css也写进去了（虽然说并没有用什么样式）： 123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt; &lt;title&gt;photo——compress&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/stylesheets/style.css\"&gt; &lt;style&gt; #modify_img&#123; display: block; width: 300px; height: 300px; background-size: 100% 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"img_post\"&gt; &lt;img src=\"images\" alt=\"\" id=\"modify_img\"&gt; &lt;input id=\"file\" type=\"file\" accept=\"image/*\"&gt; &lt;button id=\"upload\"&gt;上传&lt;/button&gt; &lt;span id=\"progress\"&gt;0%&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 下面来逐一说明，div里面的标签： “img”：必要，主要是为canvas画布固定一个位置，它必须设置为block显示， 同时设置宽高，其中的background-size属性是防止图片本来就很小而无法完全占满整个框造成显示错误的情况。 “input”：必要，设置id和input属性，同时只允许选择图片类型文件，在点击选择完文件后，会自动在”img”中生成压缩好的图片。 “button”：必要（如果不需要上传功能可忽略），点击按钮可以将压缩好的图片上传至express服务器，同时控制台会返回相关信息。 “span”：不必要，主要是为了显示上传进度。 接下来是canvas绘图的代码，因为写的时候已经注释好了，后面就不再逐一赘述： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var getfile = document.querySelector('#file'); //获取文件中id为file的元素 var reader = new FileReader(); //FileReader对象允许WEB应用程序异步读取存储在用户计算机上的文件 var img = new Image(); //Image功能等价于 document.createElement('img') var file = null; var canvas = document.createElement('canvas'); var context = canvas.getContext('2d'); //返回一个用于在画布上绘图的环境，目前唯一合法值为“2d” var newUrl = null;//对input绑定事件监听，当内容改变时触发 getfile.addEventListener('change', function(event)&#123; file = event.target.files[0]; if ( file.type.indexOf(\"image\") == 0 )&#123; reader.readAsDataURL(file); &#125; &#125;)； reader.onload = function(e)&#123; //当文件上传完后触发，主要是为了获取源文件的长宽 img.src = e.target.result; &#125;; img.onload = function()&#123; //在图片加载完成后立即发生 var orgin_width = this.width; var orgin_height = this.height; var max_width = 300; var max_height = 300; var target_width = orgin_width; var target_height= orgin_height; if (orgin_width &gt; max_width || orgin_height &gt; max_height)&#123; //判断图像是否大于限定的最大长宽 if (orgin_width / orgin_height &gt; max_width / max_height)&#123; //上传图像的宽高比较大，以宽为长轴对高进行拉伸 target_width = max_width; target_height = Math.round(max_width * ( orgin_height / orgin_width )); //round（）方法表示四舍五入取整数 &#125; else &#123; target_width = Math.round(max_height * ( orgin_width / orgin_height )); //高宽比较大，以高为长轴，对宽进行缩短 target_height = max_height; &#125; &#125; canvas.width = target_width; canvas.height = target_height; //如果是png转jpg如果canvas存在透明区域，实际绘制出来会变为黑色，因为canvas默认为rgba(0,0,0,0) //在转成jpg的时候变成了rgba(0,0,0,1),解决办法就是在绘制之前为canvas铺上一层白色的底色 context.fillStyle = \"#FFF\"; context.fillRect(0, 0, target_width, target_height); //绘制已填充矩形 //context.clearRect(0, 0, target_width, target_height); //清除画布并设置宽高 context.drawImage(img, 0, 0, target_width, target_height); //绘画 newUrl = canvas.toDataURL('image/jpeg', 0.92); //base64 格式 modify_img.style.backgroundImage='url(' + newUrl + ')'; &#125;; 设置好后点击右上角的chrome进行测试: 页面显示如下（请无视那个button的乱码，过会我们用服务器进行测试就正常了）: 为了测试，我选择了一张1.3M的照片： 点击打开后，图片会进行压缩，然后显示在”img”标签里，可以明显的通过图片的锯齿感看出图片已经进行了压缩： 这时候如果我们去检查文档，会发现图片已经被转为了base64编码： 到此，我们的canvas已经顺利完成了图片的压缩工作，接下来就是服务器上场。 四、利用Express的multer中间件实现文件与服务器的交互当时在做这一部分的时候走了很多弯路，因为express4.x已经不再包括body-parser，需要自己进行相关配置，搞得很头痛。后来发现到最新的express已经为我们提供了multer这个中间件，方便了不少，接下来先上js的代码： 1234567891011121314151617181920212223242526272829303132333435363738var upload = document.querySelector('#upload'); //为\"上传\"按钮绑定变量 var progress = document.querySelector('#progress'); //为进度条绑定变量 var xhr = new XMLHttpRequest(); //定义xhr upload.addEventListener('click', uploadFile, false); //设置按钮点击事件 function uploadFile(event)&#123; function dataURLtoFile(dataurl, filename) &#123; //将我们上面转换的base64格式编码转为文件类型 var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while(n--)&#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new File([u8arr], filename, &#123;type:mime&#125;); &#125; var file_img = dataURLtoFile(newUrl, file.name); //定义文件类型的图片 var formData = new FormData(); //定义formdata的处理方法 formData.append('test-upload', file_img); //定义处理域以及文件传入 xhr.onload = uploadSuccess; //上载成功的返回函数 xhr.upload.onprogress = setProgress; //处理进度的放回函数 xhr.open('post', '/upload', true); //ajax数据请求方法 xhr.send(formData); //ajax数据发送方法 &#125; function uploadSuccess(event)&#123; if(xhr.readyState === 4)&#123; console.log(xhr.responseText); &#125; &#125; function setProgress(event) &#123; if (event.lengthComputable) &#123; var complete = Number.parseInt(event.loaded / event.total * 100); progress.innerHTML = complete + '%'; &#125; &#125; 这里需要注意的是 123...var file_img = dataURLtoFile(newUrl, file.name); //定义文件类型的图片... 第二个参数file.name中，file为第三部分中定义过的file，目的是为了传入压缩过的文件名称，如果需要修改请将dataURLtoFile()函数一并修改。 然后我们需要对express进行一些配置，在第二部分我们已经引入中间件，那么只需要在app.js中进行引入。首先在文件头定义上传和文件这两个变量，方便我们使用，并设置好端口号：(省略号之间的为新写入的内容！！！) 1234567var logger = require('morgan');//...var upload = require('multer')(&#123; dest: 'uploads/' &#125;); //上传图片保存的文件夹为uploadsvar fs = require('fs');var port = 8000;//...var indexRouter = require('./routes/index'); 接下来定义文件的上传输出信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243app.use('/users', usersRouter);//...app.set('port', port);app.get('*', (req, res) =&gt; &#123; res.redirect('index.html');&#125;);app.post('/upload', upload.single('test-upload'), (req, res) =&gt; &#123; // 没有附带文件 if (!req.file) &#123; res.json(&#123; ok: false &#125;); return; &#125; // 输出文件信息 console.log('===================================================='); console.log('fieldname: ' + req.file.fieldname); console.log('originalname: ' + req.file.originalname); console.log('encoding: ' + req.file.encoding); console.log('mimetype: ' + req.file.mimetype); console.log('size: ' + (req.file.size / 1024).toFixed(2) + 'KB'); console.log('destination: ' + req.file.destination); console.log('filename: ' + req.file.filename); console.log('path: ' + req.file.path); // 重命名文件 let oldPath = path.join(__dirname, req.file.path); let newPath = path.join(__dirname, 'uploads/' + req.file.originalname); fs.rename(oldPath, newPath, (err) =&gt; &#123; if (err) &#123; res.json(&#123; ok: false &#125;); console.log(err); &#125; else &#123; res.json(&#123; ok: true &#125;); &#125; &#125;);&#125;);app.listen(port, () =&gt; &#123; console.log(\"[Server] localhost:\" + port);&#125;);//...module.exports = app; 至此，我们的上传功能也搭建完毕。 五、程序运行：上述操作全部完成后，因为编译器已经帮我们配好了运行环境（真的是省了一大步的事），所以我们只需要点击右上角的绿色小箭头： 运行： 这时我们的服务器已经启动了，打开chrome，输入http://localhost:8000/ 就可以看到我们的界面了，然后选择文件后点击上传，进度显示100%就代表上传成功： 控制台返回给我们图片的相关信息： 可以看到图片从1.3M压缩到了33.33KB，同时存放路径为uploads的文件夹； 接下来到我们定义好的存图片的地方： 然后，然后就开心的玩这个东西了，😝。 其实express也可以通过裁剪的方式进行图片压缩，不过那需要现将源文件上传至服务器（还是会浪费流量，而且加载速度也会受影响）；使用canvas先在本地进行图片压缩，然后上传服务器，这是目前主流的做法。本项目需要注意的点在于压缩好后的图片只是存在的标签下，而上传的需要是文件，这就需要用dataURLtoFile()这一个函数将图片进行转化，再对文件进行上传。否则将这一部分代码改为： 123...formData.append('test-upload', file); ... 上传的仍然是未被压缩的源文件。","categories":[],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://yoursite.com/tags/Nodejs/"}]},{"title":"node.js非管道方法读写错误问题","slug":"node.js传统读写流的时间先后问题","date":"2018-05-04T06:09:17.293Z","updated":"2018-05-08T05:53:39.676Z","comments":true,"path":"node.js传统读写流的时间先后问题/","link":"","permalink":"http://yoursite.com/node.js传统读写流的时间先后问题/","excerpt":"今天在学习node.js流的时候，参照菜鸟教程的文档写了从流中读取和写入数据的操作，但是在两者同时运行的时候，却发现写入文档并没有任何数据写入。 先上最初的错误代码：","text":"今天在学习node.js流的时候，参照菜鸟教程的文档写了从流中读取和写入数据的操作，但是在两者同时运行的时候，却发现写入文档并没有任何数据写入。 先上最初的错误代码： 12345678910111213141516171819202122232425262728293031//引入流模块var fs = require('fs');var data = '';var readerStream = fs.createReadStream('input.txt');var writerStream = fs.createWriteStream('output.txt'); //将文档从input.txt中读取出来存入流readerStream.on('data', function(chunk)&#123; console.log(\"1、Start:\"); data += chunk;&#125;);readerStream.on('end', function()&#123; console.log(\"2、\" + data);&#125;);readerStream.on('error', function(err)&#123; console.log(err.stack);&#125;)；//从流中读取数据写入output.txtwriterStream.write(data, 'UTF8');writerStream.end();writerStream.on('finish', function()&#123; console.log(\"3、Write done!\"); console.log(\"4、All done!\");&#125;);writerStream.on('err', function(err)&#123; console.log(err.stack);&#125;);console.log(\"5、Program Finished！\"); 1Hello world! 程序的运行结果如下： 123455、Program Finished!1、Start:3、Write done!4、All done!2、Hello world! 这时去查看同目录下生成的output.txt是没有内容的，根据以上代码，显然在进行写入操作时，data变量还没有数据读入，因此output写入数据为空（你也可以尝试定义data为一个字符串进行测试）。 接下来对写入流（writerStream）设定一个定时器，1秒后进行操作，修改代码为： 12345678...setTimeout(function()&#123; writerStream.write(data, 'UTF8');&#125;,1000);setTimeout(function()&#123; writeStream.end();&#125;,2000)... 这里需要注意，在对写操作设置定时器的时候，需要对end方法也设定定时器，并且时间需要大于我们写操作定时器的时间，不然会出现以下错误： 12Error: write after end... 最终调试到以下阶段： 123456789...setTimeout(function()&#123; writerStream.write(data, 'UTF8');&#125;,3);//定时为2则抛出'Error: write after end'setTimeout(function()&#123; writeStream.end();&#125;,5)... 可以看到从文件中读取数据至少要3ms（实际的读取时间跟文件路径以及大小有关），而程序读取完只需要不到1ms，所以才出现了最开始写入数据为空的bug。这也侧面说明了node.js的异步处理方式。 当然，其实node.js已经帮我们做好了这一堆繁杂的操作，管道流（pipe）很好的解决了这一个问题，我们的代码可以简化为： 1234567var fs = require('fs');var readerStream = fs.createReadStream('input.txt');var writeeStream = fs.createWriteStream('output.txt');readerStream.pipe(writeStream);console.log(\"All done!\"); 上述的操作会使得output.txt内容被覆写，如果你只想在output.txt中追加内容，可以在定义写入流的时候追加参数: 1var writeeStream = fs.createWriteStream('output.txt',&#123;'flags' : 'a' &#125;); 可用的参数列表如下： flag 说明 r 读取文件。如果文件不存在则抛出异常 r+ 读取并写入。如果文件不存在时抛出异常 rs 以同步方式读取文件并通知操作系统忽略本地文件系统缓存 w 写入文件。文件不存在则创建该文件，存在则清空文件内容 w+ 读取并写入文件。文件不存在则创建该文件，存在则清空文件内容 wx 作用与”w”类似。但以排他方式打开文件 wx+ 作用与”w+”类似。但以排他方式打开文件 a 以追加方式写入文件。如果文件不存在则创建该文件 a+ 读取并以追加方式写入文件。如果文件不存在则创建该文件 ax 作用与”a”相似。但以排他方式打开文件 ax+ 作用与”a+”相似。但以排他方式打开文件","categories":[],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://yoursite.com/tags/Nodejs/"}]}]}